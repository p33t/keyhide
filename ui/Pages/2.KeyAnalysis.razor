@page "/2"
@using System.ComponentModel.DataAnnotations
@inject UiState UiState
<h3>Key Analysis</h3>

<p>
    Enter the key that will be hidden among the grid of 'random' characters and select 'Analyze'.
    Confirm the parameters are correct before proceeding to next step.
</p>

<form>
    <div>
        <label>Prefix:</label>
        @* This (or suffix) is causing Index out of range error.  Leave out for now 
        <input type="text" @onchange="PrefixChanged" value="@(UiState.KeyDefinition?.Prefix)"> *@
    </div>
    <div>
        <label>Key:</label>
        <input type="text" @onchange="KeyStringChanged" value="@(UiState.KeyDefinition?.KeyString)"
               minlength="1"/>
    </div>
    <div>
        <label>Suffix:</label>
        <input type="text" @onchange="SuffixChanged" value="@(UiState.KeyDefinition?.Suffix)">
    </div>
    <div>
        <label>Fragment Separator:</label>
        <input type="text" maxlength="1" value="@(UiState.KeyDefinition?.Separator)"
               @onchange="SeparatorChanged" disabled="@(UiState.KeyDefinition == null)"/>
    </div>
    <div>
        <label>Pre-defined Characters:</label>
        <select class="custom-select" @onchange="PredefinedCharsChanged" disabled="@(UiState.KeyDefinition == null)">
            <option value="" selected="@(UiState.KeyDefinition?.CharSet == null)">(Custom)</option>
            @foreach (var charSet in Enum.GetValues<KeyCharSetEnum>())
            {
                <option value="@charSet" selected="@(charSet == UiState.KeyDefinition?.CharSet)">@charSet</option>
            }
        </select>
    </div>
    <div>
        <label>Custom Characters:</label>
        <input type="text" @onchange="CustomCharsChanged"
               value="@(UiState.KeyDefinition?.CustomCharset)"
               disabled="@(UiState.KeyDefinition == null)"/>
    </div>
    @foreach (var error in _errors)
    {
        <p>@error</p>
    }
</form>

@code {
    #nullable enable
    private IList<string> _errors = new List<string>();

    void KeyStringChanged(ChangeEventArgs evt)
    {
        var keyString = evt.Value as string;
        KeyDefinition? def = null;
        if (!string.IsNullOrEmpty(keyString))
        {
            if (UiState.KeyDefinition == null)
    // first time key entered
    // auto-analyze
                def = KeyAnalyzer.AnalyzeKeyString(keyString);
            else
                def = UiState.KeyDefinition with {KeyString = keyString};
        }
        UpdateKeyDefinition(def);
    }

    private void SuffixChanged(ChangeEventArgs evt)
    {
        if (UiState.KeyDefinition == null)
            return;

        string? suffix = null;
        if (evt.Value is string {Length: > 0 } s)
            suffix = s;
        UpdateKeyDefinition(UiState.KeyDefinition with {Suffix = suffix});
    }
    
    private void PrefixChanged(ChangeEventArgs evt)
    {
        if (UiState.KeyDefinition == null)
            return;

        string? prefix = null;
        if (evt.Value is string {Length: > 0 } s)
            prefix = s;
        UpdateKeyDefinition(UiState.KeyDefinition with {Prefix = prefix});
    }

    void SeparatorChanged(ChangeEventArgs evt)
    {
        if (UiState.KeyDefinition == null)
            return;

        char? separator;
        if (evt.Value is string {Length: > 0 } separatorStr)
            separator = separatorStr[0];
        else
            separator = null;
        UpdateKeyDefinition(UiState.KeyDefinition with {Separator = separator});
    }

    void UpdateKeyDefinition(KeyDefinition? def)
    {
        UiState.KeyDefinition = def;

        var errors = new List<ValidationResult>();
        if (def != null)
            Validator.TryValidateObject(def, new ValidationContext(def), errors, true);

        _errors = errors.Select(r => $"{string.Join(',', r.MemberNames)}: {r.ErrorMessage}")
            .ToList();
    }

    private void PredefinedCharsChanged(ChangeEventArgs evt)
    {
        if (UiState.KeyDefinition == null)
            return;

        KeyCharSetEnum? charSet;
        if (evt.Value is string {Length: > 0 } charSetStr)
            charSet = Enum.Parse<KeyCharSetEnum>(charSetStr);
        else
            charSet = null;
        UpdateKeyDefinition(UiState.KeyDefinition with {CharSet = charSet});
    }

    private void CustomCharsChanged(ChangeEventArgs evt)
    {
        if (UiState.KeyDefinition == null)
            return;

        string? custom = null;
        var charSetEnum = UiState.KeyDefinition?.CharSet;
        if (evt.Value is string {Length: > 0 } str)
        {
            custom = str;
            charSetEnum = null;
        }
        UpdateKeyDefinition(UiState.KeyDefinition with {CustomCharset = custom, CharSet = charSetEnum});
    }

}