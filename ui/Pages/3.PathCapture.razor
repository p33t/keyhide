@page "/3"
@inject UiState _uiState
@inject NavigationManager _navigationManager
<h3>Path Setup</h3>
<p>
    Define how large your grid should be. Larger is more secure but also more difficult to display and use.
</p>
<p>
    Then choose a series of cells that will define a path to inlay your key.
</p>

<div class="main">
    <EditForm EditContext="@EditContext" OnValidSubmit="@NextScreen">
        <div class="form-fields">
            <button type="button" class="next-button btn btn-warning" @OnClick="Back">Back</button>
            <button type="submit" class="next-button btn btn-warning">Next</button>
            <div class="form-field">
                <label>Columns:</label>
                <div>
                    @* Can't bind value and listen for change *@
                    @* <InputNumber @bind-Value="_uiState.GridSetup.ColCount" @OnChange="ColCountChange"/> *@
                    <input type="number" value="@(_uiState.PathDefinition.ColCount)" @onchange="ColCountChange"
                           min="@PathDefinition.MinCount" max="@PathDefinition.MaxCount"/>
                    <ValidationMessage For="@(() => _uiState.PathDefinition.ColCount)"/>
                </div>
            </div>
            <div class="form-field">
                <label>Rows:</label>
                <div>
                    <input type="number" value="@(_uiState.PathDefinition.RowCount)" @onchange="RowCountChange"
                           min="@PathDefinition.MinCount" max="@PathDefinition.MaxCount"/>
                    <ValidationMessage For="@(() => _uiState.PathDefinition.RowCount)"/>
                </div>
            </div>
            <div class="form-field">
                <label>Path:</label>
                <div>
                    @if (_uiState.PathDefinition.Coords.Any())
                    {
                        @(string.Join(' ', _uiState.PathDefinition.Coords))<br/>
                    }
                    else
                    {
                        <text>(Empty)</text>
                        <br/>
                    }
                    <button type="button" @onclick="Reset">Reset</button>
                    <button type="button" @onclick="Undo">Undo</button>
                    <ValidationMessage For="@(() => _uiState.PathDefinition.Coords)"/>
                </div>
            </div>
        </div>
        <DataAnnotationsValidator/>
    </EditForm>
    <GridDisplay Grid="Grid" OnCellSelect="CellClick"/>
</div>


@code {
    private CoordGrid<DisplayCell> Grid { get; set; } = new(GridSetupModel.DefaultColCount, GridSetupModel.DefaultRowCount);
    private EditContext EditContext { get; set; } = null!;

    protected override void OnInitialized()
    {
        EditContext = new EditContext(_uiState.PathDefinition);
        base.OnInitialized();
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        SyncGrid();
    }

    private void CellClick(CellCoord clicked)
    {
        if (PathOperations.Trace(_uiState.PathDefinition.Coords).Count() < (_uiState.PathDefinition.EffectiveKeyString?.Length ?? 0))
        {
            _uiState.PathDefinition.Coords = _uiState.PathDefinition.Coords.Append(clicked);
            SyncGrid();
        }
    // else already have enough path
    }

    private void SyncGrid()
    {
        if (_uiState.PathDefinition.EffectiveKeyString != null)
        {
            Grid.Reset();
            var remaining = _uiState.PathDefinition.EffectiveKeyString;
            CellCoord? last = null;
            foreach (var coord in PathOperations.Trace(_uiState.PathDefinition.Coords))
            {
                if (!remaining.Any() || !Grid.Contains(coord))
                    break;

                var ch = remaining[0];
                remaining = remaining[1..];
                Grid[coord] = new DisplayCell {Content = ch};
                last = coord;
            }

            foreach (var coord in Grid.AllCoords())
            {
                var displayCell = Grid[coord] ?? DisplayCell.Default;
                var isAvailable = last == null || PathOperations.CoordIsAvailable(coord, c => Grid[c]?.Content, last, remaining);
                if (isAvailable != displayCell.IsAvailable)
                {
                    Grid[coord] = displayCell with {IsAvailable = isAvailable};
                }
            }
        }
        EditContext.Validate();
    }

    private void Undo()
    {
        var count = _uiState.PathDefinition.Coords.Count();
        if (count > 0)
        {
            _uiState.PathDefinition.Coords = _uiState.PathDefinition.Coords.Take(count - 1);
            SyncGrid();
        }
    }

    private void Reset()
    {
        int SafeCount(int i) => Math.Max(Math.Min(i, PathDefinition.MaxCount), PathDefinition.MinCount);
        var colCount = SafeCount(_uiState.PathDefinition.ColCount);
        var rowCount = SafeCount(_uiState.PathDefinition.RowCount);
        Grid = new CoordGrid<DisplayCell>(colCount, rowCount);
        _uiState.PathDefinition.Coords = Enumerable.Empty<CellCoord>();
    }

    private void NextScreen()
    {
        _uiState.ValidPathDefinition = _uiState.PathDefinition.DeepCopy();
        _navigationManager.NavigateTo("4");
    }

    private void ColCountChange(ChangeEventArgs evt)
    {
        if (int.TryParse((string) evt.Value!, out var colCount) && _uiState.PathDefinition.ColCount != colCount)
        {
            _uiState.PathDefinition.ColCount = colCount;
            Reset();
            EditContext.Validate();
        }
    }

    private void RowCountChange(ChangeEventArgs evt)
    {
        if (int.TryParse((string) evt.Value!, out var colCount) && _uiState.PathDefinition.RowCount != colCount)
        {
            _uiState.PathDefinition.RowCount = colCount;
            Reset();
            EditContext.Validate();
        }
    }

    private void Back()
    {
        _navigationManager.NavigateTo("2");
    }

}